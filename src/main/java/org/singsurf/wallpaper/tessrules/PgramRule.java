/**
 * 
 */
package org.singsurf.wallpaper.tessrules;

import org.singsurf.wallpaper.FundamentalDomain;
import org.singsurf.wallpaper.Vec;

public abstract class PgramRule extends TessRule
{
    Vec fund[]= new Vec[4];

    public PgramRule(String name, String message) {
        super(name, message);
    }

    int det=1;

    //@Override
    public void calcFrame(FundamentalDomain fd,int selVert, boolean constrained)
    {
    	Vec u = fd.cellVerts[2].sub(fd.cellVerts[1]);
    	Vec v = fd.cellVerts[0].sub(fd.cellVerts[1]);
    	det = u.cross(v);
    	frameO.set(fd.cellVerts[1]);
    	frameU.set(v);
    	frameV.set(u);
    	
//        int u1,u2,v1,v2; //,w1,w2;

//        u1 =	fd.cellVerts[2].x - fd.cellVerts[1].x;
//        u2 =	fd.cellVerts[2].y - fd.cellVerts[1].y;
//        v1 =	fd.cellVerts[0].x - fd.cellVerts[1].x;
//        v2 =	fd.cellVerts[0].y - fd.cellVerts[1].y;
//        det = u1 * v2 - v1 * u2;
//        frameO.x = fd.cellVerts[1].x;
//        frameO.y = fd.cellVerts[1].y;
//        frameU.x = v1;
//        frameU.y = v2;
//        frameV.x = u1;
//        frameV.y = u2;
    }

    //@Override
    public void fixVerticies(FundamentalDomain fd)
    {
    	fd.cellVerts[0].set(frameO.add(frameU));
    	fd.cellVerts[2].set(frameO.add(frameV));
    	fd.cellVerts[3].set(frameO.add(frameU).add(frameV));
    	
//        fd.cellVerts[0].x = frameO.x+frameU.x;
//        fd.cellVerts[0].y = frameO.y+frameU.y;
//        fd.cellVerts[2].x = frameO.x+frameV.x;
//        fd.cellVerts[2].y = frameO.y+frameV.y;
//        fd.cellVerts[3].x = frameO.x+frameU.x+frameV.x;
//        fd.cellVerts[3].y = frameO.y+frameU.y+frameV.y;
        fd.numSelPoints = 3;
        fd.numOuterPoints = 4;
        fd.setLatticeType(FundamentalDomain.PARALLOGRAM);
    }

    public static TessRule rhombusTT = new PgramRule("P1",
            "The simplest possible pattern just consisting of two translations.\n"
            +"The translations can be at any angle.\n"
            +"All other patterns also have two translation symmetries\n"
            +"as you can observe by examining the yellow polygon.\n"
            +"The rest of the pattern can always be generated by translating\n"
            +"the area inside this polygon.\n"
            +"\n"
            +"This is actually the most common pattern found in wrapping paper\n"
            +"where the same motif is repeated across the image.\n"
            +"\n"
            +"The boundary of the fundamental domain does not have to be\n"
            +"straight lines.") {
        /** Calculates the fundamental domain */
        //@Override
        public void calcFund(FundamentalDomain fd)
       {
        	fd.fund[0].set(fd.cellVerts[1]);
        	fd.fund[1].set(fd.cellVerts[1].add(frameU));
        	fd.fund[2].set(fd.cellVerts[1].add(frameU).add(frameV));
        	fd.fund[3].set(fd.cellVerts[1].add(frameV));
            fd.numFund = 4;

//        	fd.fund[0].x = fd.cellVerts[1].x; 
//            fd.fund[0].y = fd.cellVerts[1].y;
//            fd.fund[1].x = fd.cellVerts[1].x+frameU.x;
//            fd.fund[1].y = fd.cellVerts[1].y+frameU.y;
//            fd.fund[2].x = fd.cellVerts[1].x+frameU.x+frameV.x;
//            fd.fund[2].y = fd.cellVerts[1].y+frameU.y+frameV.y;
//            fd.fund[3].x = fd.cellVerts[1].x+frameV.x;
//            fd.fund[3].y = fd.cellVerts[1].y+frameV.y;
        }

        //@Override
        public void fun(int[] in,int[] out,int det)
        {
            int alpha = in[0] % det; if(alpha < 0) alpha = alpha + det;
            int beta = in[1] % det; if(beta < 0) beta = beta + det;
            out[0] = alpha;
            out[1] = beta;
        }

        //@Override
        public double approxArea() {
            return 0.5;
        }	

        //@Override
        public void paintDomainEdges(Vec U, Vec V, Vec O,int det) {
            Vec A = O.add(U);
            Vec D = O.add(V);
            this.drawSimpleEdge(O,A);
            this.drawSimpleEdge(O,D);
        }

    };



    public static TessRule rhombusR1 = new PgramRule("P2",
            "The next simplest pattern with just one 180\u00ba rotation.\n"
            +"This is the only other pattern where the two translations have\n"
            +"full freedom of movement."
    ) {
        static final boolean TRIANGLE_STYLE = true;

        //@Override
        public void calcFund(FundamentalDomain fd)
        {
            if(TRIANGLE_STYLE) {
                fd.fund[0].set(fd.cellVerts[0]);
                fd.fund[1].set(fd.cellVerts[1]);
                fd.fund[2].set(fd.cellVerts[2]);
                fd.numFund=3;
            } else {
                if(det<0)
                {
                    fd.fund[0].x = fd.cellVerts[1].x; 
                    fd.fund[0].y = fd.cellVerts[1].y;
                    fd.fund[1].x = fd.cellVerts[1].x+frameU.x/2;
                    fd.fund[1].y = fd.cellVerts[1].y+frameU.y/2;
                    fd.fund[2].x = fd.cellVerts[1].x+frameU.x/2+frameV.x;
                    fd.fund[2].y = fd.cellVerts[1].y+frameU.y/2+frameV.y;
                    fd.fund[3].x = fd.cellVerts[1].x+frameV.x;
                    fd.fund[3].y = fd.cellVerts[1].y+frameV.y;
                }
                else
                {
                    fd.fund[0].x = fd.cellVerts[1].x; 
                    fd.fund[0].y = fd.cellVerts[1].y;
                    fd.fund[1].x = fd.cellVerts[1].x+frameU.x;
                    fd.fund[1].y = fd.cellVerts[1].y+frameU.y;
                    fd.fund[2].x = fd.cellVerts[1].x+frameU.x+frameV.x/2;
                    fd.fund[2].y = fd.cellVerts[1].y+frameU.y+frameV.y/2;
                    fd.fund[3].x = fd.cellVerts[1].x+frameV.x/2;
                    fd.fund[3].y = fd.cellVerts[1].y+frameV.y/2;
                }
                fd.numFund = 4;
            }
        }

        //@Override
        public void fun(int[] in,int[] out,int det)
        {
            int alpha = in[0] % det; if(alpha < 0) alpha = alpha + det;
            int beta = in[1] % det; if(beta < 0) beta = beta + det;
            if(TRIANGLE_STYLE) {
                if((alpha+beta) > det)
                {
                    alpha = det - alpha;
                    beta = det - beta;
                }

            }
            else {
                //           if(det > 0) {
                if(2 * alpha > det)
                {
                    alpha = det - alpha;
                    beta = det - beta;
                }
                //            }
                //            else {
                //                if(2 * beta > det)
                //                {
                //                    alpha = det - alpha;
                //                    beta = det - beta;
                //                }
                //            }
            }
            //                    
            out[0] = alpha;
            out[1] = beta;
        }

        //@Override
        protected void paintSymetries(Vec u, Vec v, Vec O) {
            drawRotationPoint(O,2);
            drawRotationPoint(u.div(2).add(O),2);
            drawRotationPoint(v.div(2).add(O),2);
            drawRotationPoint(Vec.linComb(1,u,1,v,2,O,2),2);
        }

        //@Override
        public void paintDomainEdges(Vec U, Vec V, Vec O,int det) {
            if (TRIANGLE_STYLE) {
                this.drawSimpleEdge(O,O.add(U));
                this.drawSimpleEdge(O.add(U),O.add(V));
                this.drawSimpleEdge(O.add(V),O);
            } else {
                Vec A = O.add(U);
                Vec B = Vec.linComb(2, O, 1,U,2);
                Vec C = Vec.linComb(2, O, 1, U,2,V,2);
                Vec D = O.add(V);
                this.drawSimpleEdge(O,A);
                this.drawSimpleEdge(B,C);
                this.drawSimpleEdge(O,D);
            }
        }

        //@Override
        public double approxArea() { return 0.25; }

        //@Override
        public double approxAspect() { return 2.0; }

    };

}